# -*- sh -*-
#[[ -z ${MY_BASHRC_$SHLVL} ]] && CYG_SYS_BASHRC="1" || return

shecho(){
    #echo "$@"
    :
}
shecho start shellrc 

if [ "$LOGGING_RUNNING" != 1 ]; then
    logdir=~/.shell-logging
    mkdir -p $logdir
    tt="$(date '+%Y-%m-%d %H-%M-%S')"
    export LOGGING_RUNNING=1
    exec script "$logdir/$tt-log" -f --timing="$logdir/$tt-timing"
fi
shecho script started

if [ -n "$ZSH_VERSION" ]; then
#======= ZSH PROMPT =======
    autoload promptinit
    promptinit
    prompt adam2
#======= ZSH keybindings =======
    bindkey '^[[1;5C' emacs-forward-word
    bindkey '^[[1;5D' emacs-backward-word
    bindkey '^[[F'    end-of-line
    bindkey '^[[H'    beginning-of-line
    bindkey "^[[3~"   delete-char
    bindkey "^[3;5~"  delete-char
#=== zhelp ===
	zhelp()
	{
		echo help "$@" | bash
	}
fi
shecho keydindings applied

#=== xeon addres ===
XEON=feelus@sanc.jinr.ru
XEONSVN=svn+ssh://$XEON/usr/local/svn/sanc/fortran
BASTION=fuskov@bastion.desy.de
NAFHHH=fuskov@nafhh-atlas03.desy.de


#=== PATH ===
[ -z "$(echo "$PATH" | grep "$HOME/scripts")" ] &&
	PATH="$PATH":"$HOME/scripts"


#=== runcpp options ===
export RUNCPP_OPTIONS="-std=gnu++11 -Wall -Wno-parentheses"

#=== LANGuage ===
export LANG=ru_RU.UTF-8
export LANGUAGE=ru
export LC_NUMERIC=en_US.UTF-8

shecho variables setted

#=== windows program launchers ===
if [ $(uname -o) = Cygwin ]; then
	printargs(){
		while [ $# -gt 0 ]; do
			echo "$1"
			shift
		done
	}
	winlaunch(){
		command="$1"; shift
		prefix="$1"; shift
		if [ -n "$BASH_VERSION" ]; then
			i=0;
			while [ $# -gt 0 ]; do
				arr[$i]="$prefix$(cygpath -m "$1")"
				i=$(($i + 1))
				shift
			done
			#printargs "$command" "${arr[@]}" 
			"$command" "${arr[@]}" 
		else
			if [ $# -gt 1 ] ; then
				for arg in "$@" ; do
					if [ "$arg" = '/cygdrive/*' ]; then
						echo вот в bash так можно, а здесь с абсолютным путем только по одному аргументу >&2
						return 1
					fi
				done
				#printargs "$command" "$@"
				"$command" "$@"
			else
				#printargs "$command" "$prefix$(cygpath -m "$1")" 
				"$command" "$prefix$(cygpath -m "$1")" 
			fi
		fi
	}
	npp(){
		winlaunch	"$(cygpath -u "$PROGRAMFILES")"/Notepad++/notepad++.exe "" "$@" 
	}
	firefox(){
		winlaunch	"$(cygpath -u "$PROGRAMFILES")/Mozilla Firefox/firefox.exe" "file:///" "$@"
	}
	opera(){
		winlaunch	"$(cygpath -u "$PROGRAMFILES")"/Opera/launcher.exe "file:///" "$@"
	}
fi

#======== SELF ALIASES ========
#=== rm ===
alias rm=rm-to-trash
alias rmf='env rm'

#=== cp ===
[ -z "$(alias cp 2>/dev/null)" ] && alias cp='cp -ir' || alias cp

#=== mv ===
[ -z "$(alias mv 2>/dev/null)" ] && alias mv='mv -ir' || alias mv

#=== grep ===
[ -z "$(alias grep 2>/dev/null)" ] && alias grep='grep --color=auto  --binary-files=text' || alias grep

#======== my aliases-and-functions ========
source ~/scripts/aliases-and-functions


#=== ls ===
[ -z "$(alias ls 2>/dev/null)" ] && alias ls="ls --escape --color=auto --group-directories-first" || alias ls
[ -z "$(alias ll 2>/dev/null)" ] && alias ll="ls -Al" || alias ll
[ -z "$(alias la 2>/dev/null)" ] && alias la="ls -A" || alias la

#=== cd ===
#alias cd='cd -P'
alias ..="cd .."
alias ....='cd ../..'
alias ......="cd ../../.."
alias ........="cd ../../../.."
alias ..........="cd ../../../../.."
alias ............="cd ../../../../../.."
alias ..............="cd ../../../../../../.."
alias ................="cd ../../../../../../../.."

#=== cygserver ===
#echo cygwin threads, run by superuser
#[ "$(uname -o)" = Cygwin ] && reg query "hku\S-1-5-19" >/dev/nul 2>/dev/nul &&
#        cygrunsrv -S cygserver #&& echo set for cygwin


#=== mycd ===
alias cd=mycd
alias dirs='dirs -p'
alias cd-='cd -'
alias cd--='cd --'
alias cd---='cd ---'
alias cd----='cd ----'
alias cd-----='cd -----'
alias cd------='cd ------'
alias cd+='cd +'
alias cd++='cd ++'
alias cd+++='cd +++'
alias cd++++='cd ++++'
alias cd+++++='cd +++++'
alias cd++++++='cd ++++++'

shecho aliases setted

mycd()
{
    local dirok=0
    [ "$(pwd)" = "$(pwd -P)" ] && dirok=1 # физ и логич пути к директории совпадают
    if [ $# = 0 ]; then
		pushd ~ >/dev/null 
		#если раньше совпадали, а теперь нет, то нужно сделать, чтобы они все-таки совпадали 
		[ $dirok = 1 ] && [ "$(pwd)" != "$(pwd -P)" ] && pushd "$(pwd -P)"
		DIRS2=
		ls
		return
    fi
    if [ "$1" = - -o -n "$(echo "$1" | grep -xe '-*')" ]; then
		local arg=$1
		local tmp
		while [ -n "$arg" ]; do
		    read tmp < <(dirs) 
		    push DIRS2 "$tmp"
		    popd >/dev/null
		    arg=${arg#-}
		done

		printf "%s\n---> " "$DIRS2"
		dirs
		return
    fi
    if [ -n "$(echo "$1" | grep -xe '+*')" ]; then
		local arg=$1
		local tmp
		while [ -n "$arg" ]; do
		    popto DIRS2 tmp
		    [ -z "$tmp" ] && return
		    [ "$tmp" != "${tmp#\~}" ] && tmp=~"${tmp#\~}"
		    #echo "$tmp"
		    pushd "$tmp" > /dev/null
		    arg=${arg#+}
		done
		
		printf "%s\n---> " "$DIRS2"
		dirs
		return
    fi
    pushd "$1" >/dev/null || return -1
    [ $dirok = 1 ] && [ "$(pwd)" != "$(pwd -P)" ] && pushd "$(pwd -P)"
    DIRS2=
    ls
}

shecho func mycd defined

#=== ewd ===
if [ $(uname -o) = Cygwin ]; then
#    if [ -n $(systeminfo.exe | grep 'OS Name:.*XP') ]; then
    case "$(cmd /C ver | grep -iE 'Microsoft.*Windows' | grep -o '[0-9]\.[0-9]')" in 
	5*) alias ewd='explorer $(cygpath -w $(pwd))' ;;
	6*) alias ewd='cmd /c start.' ;;
	*) echo shellrc: unknown version of microsoft windows, and therefore ewd is not set >&2;;
    esac
else
    if [ -n "$(which caja)" ]; then
	alias ewd='caja .'
    else
	echo shellrc: at unix, caja not found, and therefore ewd is not set >&2
    fi
fi
shecho ewd setted

#=== do by start ===
shecho ls started
ls
